<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flames in the Fold - Event Selection</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Montserrat:wght@500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        #ui-layer {
            position: absolute; bottom: 30px; width: 100%; text-align: center; pointer-events: none;
        }
        .instruction {
            color: #d4af37; font-family: 'Cinzel', serif; font-size: 0.9rem; letter-spacing: 3px;
            opacity: 0; transition: opacity 1s ease;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="instruction" id="instruct-text">SELECT A CATEGORY</div>
    </div>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        // --- CONFIGURATION ---
        const CONFIG = {
            cardWidth: 50,
            cardHeight: 14,
            closedAngle: 1.55,  // ~89 degrees (Closed)
            openAngle: 0.25,    // ~15 degrees (Open)
            categories: [
                "PERFORMING ARTS",
                "LITERARY & ORATORY",
                "VISUAL & FINE ARTS",
                "GAMING & ESPORTS",
                "MEDIA & PHOTO"
            ]
        };

        let isInteracting = false; 
        let isClosing = false;     

        // --- SCENE ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020202); 
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(0, 0, 90); 
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(0, 50, 60);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.bias = -0.001; 
        scene.add(dirLight);

        const greenLight = new THREE.PointLight(0x39ff14, 2, 80);
        greenLight.position.set(0, -60, 30);
        scene.add(greenLight);

        const shadowPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(500, 500),
            new THREE.MeshStandardMaterial({ color: 0x020202, roughness: 1 })
        );
        shadowPlane.position.z = -20;
        shadowPlane.receiveShadow = true;
        scene.add(shadowPlane);

        // --- TEXTURE ---
        function createCardTexture(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Gold Gradient
            const grad = ctx.createLinearGradient(0,0,0,256);
            grad.addColorStop(0, '#8a6e28'); 
            grad.addColorStop(0.2, '#d4af37'); 
            grad.addColorStop(0.5, '#fcf6ba'); 
            grad.addColorStop(0.8, '#d4af37'); 
            grad.addColorStop(1, '#8a6e28'); 
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,1024,256);

            // Noise
            ctx.fillStyle = "rgba(0,0,0,0.08)";
            for(let i=0; i<8000; i++) ctx.fillRect(Math.random()*1024, Math.random()*256, 2, 2);

            // Text
            ctx.font = "bold 80px 'Cinzel', serif";
            ctx.fillStyle = "#011f18"; 
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text, 512, 128);

            const tex = new THREE.CanvasTexture(canvas);
            tex.anisotropy = 16;
            return tex;
        }

        // --- MESH SETUP ---
        const hinges = [];
        const meshes = [];

        const rootGroup = new THREE.Group();
        rootGroup.position.set(0, 35, 0); 
        scene.add(rootGroup);

        let parent = rootGroup;

        CONFIG.categories.forEach((cat, i) => {
            const hinge = new THREE.Group();
            if(i > 0) hinge.position.y = -CONFIG.cardHeight;
            parent.add(hinge);
            hinges.push(hinge);
            parent = hinge;

            const geom = new THREE.PlaneGeometry(CONFIG.cardWidth, CONFIG.cardHeight, 40, 1);
            geom.translate(0, -CONFIG.cardHeight/2, 0);

            const mat = new THREE.MeshStandardMaterial({
                map: createCardTexture(cat),
                side: THREE.DoubleSide,
                roughness: 0.5, // Standard paper roughness
                metalness: 0.6, // Standard gold shine
                emissive: new THREE.Color(0x000000), 
                emissiveIntensity: 0
            });

            const mesh = new THREE.Mesh(geom, mat);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData = { id: i, name: cat };
            
            hinge.add(mesh);
            meshes.push(mesh);
        });

        // --- ANIMATION HELPER ---
        function updateFolds(angle) {
            hinges.forEach((h, i) => {
                if(i === 0) h.rotation.x = angle;
                else {
                    const sign = (i % 2 === 0) ? 1 : -1;
                    h.rotation.x = angle * 2 * sign;
                }
            });
        }

        // --- INTRO ---
        const animState = { angle: CONFIG.closedAngle };
        updateFolds(CONFIG.closedAngle);

        gsap.to(animState, {
            angle: CONFIG.openAngle,
            duration: 2.5,
            ease: "elastic.out(1, 0.75)",
            delay: 0.5,
            onUpdate: () => updateFolds(animState.angle),
            onComplete: () => {
                isInteracting = true;
                document.getElementById('instruct-text').style.opacity = 1;
            }
        });

        // --- INTERACTION ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredIndex = -1;

        window.addEventListener('mousemove', (e) => {
            if(!isInteracting || isClosing) return;

            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(meshes);

            if(intersects.length > 0) {
                const index = intersects[0].object.userData.id;
                if(hoveredIndex !== index) {
                    hoveredIndex = index;
                    updateHoverState();
                    document.body.style.cursor = 'pointer';
                }
            } else {
                if(hoveredIndex !== -1) {
                    hoveredIndex = -1;
                    updateHoverState();
                    document.body.style.cursor = 'default';
                }
            }
        });

        function updateHoverState() {
            meshes.forEach((mesh, i) => {
                if(i === hoveredIndex) {
                    // ACTIVE STATE:
                    // 1. Set Emissive to Neon Green
                    // 2. Set Intensity High (overpowers shadows)
                    // 3. Set Metalness to 0 (removes reflections that reveal angle)
                    // 4. Set Roughness to 1 (makes surface matte/flat)
                    gsap.to(mesh.material.emissive, { r: 0.22, g: 1, b: 0.08, duration: 0.2 }); 
                    gsap.to(mesh.material, { 
                        emissiveIntensity: 1.5, // High intensity for "Flat" look
                        metalness: 0.0, 
                        roughness: 1.0, 
                        duration: 0.2 
                    });
                    // Slight lift
                    gsap.to(mesh.position, { z: 2, duration: 0.3 }); 
                } else {
                    // INACTIVE STATE: Reset to Gold Paper physics
                    gsap.to(mesh.material.emissive, { r: 0, g: 0, b: 0, duration: 0.2 });
                    gsap.to(mesh.material, { 
                        emissiveIntensity: 0, 
                        metalness: 0.6, 
                        roughness: 0.5, 
                        duration: 0.2 
                    });
                    gsap.to(mesh.position, { z: 0, duration: 0.3 });
                }
            });
        }

        // --- EXIT ANIMATION ---
        window.addEventListener('click', () => {
            if(hoveredIndex !== -1 && !isClosing && isInteracting) {
                isClosing = true;
                const selectedCategory = meshes[hoveredIndex].userData.name;
                
                document.getElementById('instruct-text').style.opacity = 0;

                // 1. IMMEDIATELY KILL THE GLOW
                // We force the currently hovered mesh back to normal physics
                // so it looks like gold when it folds up.
                gsap.to(meshes[hoveredIndex].material.emissive, { r: 0, g: 0, b: 0, duration: 0.2 });
                gsap.to(meshes[hoveredIndex].material, { 
                    emissiveIntensity: 0, 
                    metalness: 0.6, 
                    roughness: 0.5, 
                    duration: 0.2 
                });
                gsap.to(meshes[hoveredIndex].position, { z: 0, duration: 0.2 });

                // 2. FOLD UP
                gsap.to(animState, {
                    angle: CONFIG.closedAngle,
                    duration: 1.0,
                    ease: "power3.inOut",
                    onUpdate: () => updateFolds(animState.angle),
                    onComplete: () => {
                        console.log(`Navigating to: ${selectedCategory}`);
                        alert("Navigating to " + selectedCategory);
                    }
                });
            }
        });

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>