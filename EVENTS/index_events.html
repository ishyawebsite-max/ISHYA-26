<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ISHYA '26 | Event Selection</title>
    
    <!-- FONTS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Syncopate:wght@400;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <!-- ANIMATION LIB -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    
    <style>
        :root {
            --bg-dark: #051408;       
            --accent-gold: #D6C26A;   
            --font-tech: 'Share Tech Mono', monospace;
        }

        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: var(--bg-dark); 
            font-family: var(--font-tech);
        }

        #font-loader { 
            font-family: 'Cinzel'; font-weight: 900; opacity: 0; position: absolute; pointer-events: none; 
        }

        #animated-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -10; pointer-events: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        
        .overlay-grain {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.04'/%3E%3C/svg%3E");
            pointer-events: none; z-index: 5; opacity: 0.6;
        }
    </style>
</head>
<body>

    <div id="font-loader">ISHYA LOADING</div>
    <canvas id="animated-bg"></canvas>
    <div class="overlay-grain"></div>
    <div id="canvas-container"></div>

    <!-- SCRIPT 1: BACKGROUND ANIMATION -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('animated-bg');
            const ctx = canvas.getContext('2d');
            let width, height;
            
            const isMobile = window.innerWidth < 950;
            const COLORS = { 
                bg: '#051408', 
                trail: 'rgba(5, 20, 8, 0.15)',
                swirlGreen: 'rgba(77, 183, 72, 0.1)', 
                gold: 'rgba(214, 194, 106, 0.3)', 
                mandala: 'rgba(214, 194, 106, 0.08)' 
            };
            
            const particles = []; 
            let mandalas = [];

            function resize() {
                width = canvas.width = window.innerWidth; 
                height = canvas.height = window.innerHeight;
                mandalas = [new Mandala(width/2, height*0.4, Math.min(width,height)*0.45, 0.0005, COLORS.mandala)];
                particles.length = 0;
                const pCount = isMobile ? 30 : 100;
                for(let i=0; i<pCount; i++) particles.push(new FlowParticle());
            }

            class FlowParticle {
                constructor() { 
                    this.x = Math.random()*width; this.y = Math.random()*height; 
                    this.speed = Math.random()*1.0+0.2; this.angle = 0; this.size = Math.random()*2+0.5;
                    this.color = Math.random()>0.8 ? COLORS.gold : COLORS.swirlGreen; 
                }
                update() { 
                    const n = Math.sin(this.x*0.002) * Math.cos(this.y*0.002);
                    this.angle = n * Math.PI * 4; 
                    this.x += Math.cos(this.angle)*this.speed; this.y += Math.sin(this.angle)*this.speed;
                    if(this.x<0)this.x=width; if(this.x>width)this.x=0; if(this.y<0)this.y=height; if(this.y>height)this.y=0;
                }
                draw() { ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); }
            }

            class Mandala {
                constructor(x,y,r,s,c) { this.x=x;this.y=y;this.r=r;this.s=s;this.angle=0;this.c=c; }
                update() { this.angle+=this.s; }
                draw() {
                    ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle); ctx.strokeStyle=this.c; ctx.lineWidth=2;
                    for(let i=0;i<12;i++){
                        ctx.rotate(Math.PI*2/12); ctx.beginPath(); ctx.moveTo(0,0);
                        ctx.quadraticCurveTo(this.r*0.5,this.r*0.5,0,this.r);
                        ctx.quadraticCurveTo(-this.r*0.5,this.r*0.5,0,0); ctx.stroke();
                    }
                    ctx.restore();
                }
            }

            function animate() { 
                ctx.fillStyle=COLORS.trail; ctx.fillRect(0,0,width,height); 
                mandalas.forEach(m=>{m.update();m.draw();}); 
                particles.forEach(p=>{p.update();p.draw();}); 
                requestAnimationFrame(animate); 
            }
            window.addEventListener('resize', resize); resize(); animate();
        });
    </script>

    <!-- SCRIPT 2: THREE.JS LOGIC -->
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        // --- CONFIG ---
        const CONFIG = {
            bannerWidth: 50,
            bannerHeight: 18, 
            cardWidth: 50,
            cardHeight: 14,
            closedAngle: 1.55, 
            openAngle: 0.18,   
            categories: [
                "PERFORMING ARTS",
                "LITERARY & ORATORY",
                "VISUAL & FINE ARTS",
                "GAMING & ESPORTS",
                "MEDIA & PHOTO"
            ]
        };

        async function initApp() {
            await document.fonts.ready;
            
            // --- SCENE ---
            const container = document.getElementById('canvas-container');
            const scene = new THREE.Scene();
            scene.background = null; 
            
            const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 0, 110); 
            
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // --- LIGHTING ---
            const ambLight = new THREE.AmbientLight(0x051408, 0.8);
            scene.add(ambLight);

            const dirLight = new THREE.DirectionalLight(0xD6C26A, 1.8);
            dirLight.position.set(10, 50, 60);
            dirLight.castShadow = true;
            dirLight.shadow.bias = -0.001; 
            scene.add(dirLight);

            // --- TEXTURES ---
            function createBannerTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 1024; canvas.height = 368;
                const ctx = canvas.getContext('2d');

                const grad = ctx.createLinearGradient(0,0,0,368);
                grad.addColorStop(0, '#3e2b18'); grad.addColorStop(0.5, '#5a461b'); grad.addColorStop(1, '#3e2b18');
                ctx.fillStyle = grad; ctx.fillRect(0,0,1024,368);

                ctx.fillStyle = "rgba(0,0,0,0.2)";
                for(let i=0; i<10000; i++) ctx.fillRect(Math.random()*1024, Math.random()*368, 2, 2);
                
                ctx.lineWidth = 15; ctx.strokeStyle = "#D6C26A"; ctx.strokeRect(10,10,1004,348);

                ctx.font = "900 110px 'Cinzel', serif";
                ctx.fillStyle = "#D6C26A"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.shadowColor="rgba(0,0,0,0.5)"; ctx.shadowBlur=10;
                ctx.fillText("ISHYA '26", 512, 140);
                
                ctx.shadowBlur=0;
                ctx.font = "700 35px 'Syncopate', sans-serif";
                ctx.fillStyle = "#e0e0e0"; ctx.letterSpacing = "5px";
                ctx.fillText("FLAMES IN THE FOLD", 512, 250);

                const tex = new THREE.CanvasTexture(canvas);
                tex.colorSpace = THREE.SRGBColorSpace;
                tex.minFilter = THREE.LinearFilter;
                return tex;
            }

            function createCardTexture(text, type) {
                const canvas = document.createElement('canvas');
                canvas.width = 1024; canvas.height = 256;
                const ctx = canvas.getContext('2d');

                if (type === 'normal') {
                    // NORMAL: Gold BG, Dark Text
                    const grad = ctx.createLinearGradient(0,0,0,256);
                    grad.addColorStop(0, '#8a6e28'); grad.addColorStop(0.2, '#D6C26A'); 
                    grad.addColorStop(0.5, '#fcf6ba'); grad.addColorStop(0.8, '#D6C26A'); grad.addColorStop(1, '#8a6e28');
                    ctx.fillStyle = grad; ctx.fillRect(0,0,1024,256);
                    
                    ctx.fillStyle = "rgba(0,0,0,0.12)";
                    for(let i=0; i<8000; i++) ctx.fillRect(Math.random()*1024, Math.random()*256, 1.5, 1.5);
                    
                    ctx.font = "900 65px 'Cinzel', serif";
                    ctx.fillStyle = "#051408"; 
                } else {
                    // HOVER: Dark BG, Bright Gold Text
                    ctx.fillStyle = "#051408"; // Solid Dark Theme Color
                    ctx.fillRect(0,0,1024,256);
                    
                    // Very subtle grain on background
                    ctx.fillStyle = "rgba(255,255,255,0.03)";
                    for(let i=0; i<2000; i++) ctx.fillRect(Math.random()*1024, Math.random()*256, 1, 1);

                    // Bright Gold Text
                    ctx.font = "900 65px 'Cinzel', serif";
                    ctx.fillStyle = "#D6C26A";
                }

                ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.fillText(text, 512, 128);
                
                if (type === 'hover') {
                    // Crisp gold border for visibility
                    ctx.lineWidth = 15; ctx.strokeStyle = "#D6C26A"; ctx.strokeRect(0,0,1024,256);
                }

                const tex = new THREE.CanvasTexture(canvas);
                tex.colorSpace = THREE.SRGBColorSpace;
                tex.anisotropy = 16;
                return tex;
            }

            // --- MESH GENERATION ---
            const hinges = [];
            const meshes = [];

            const rootGroup = new THREE.Group();
            rootGroup.position.set(0, 42, 0); 
            scene.add(rootGroup);

            // Banner (Standard Material to catch light/shadows)
            const bannerGeom = new THREE.PlaneGeometry(CONFIG.bannerWidth, CONFIG.bannerHeight);
            const bannerMat = new THREE.MeshStandardMaterial({
                map: createBannerTexture(),
                roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide
            });
            const bannerMesh = new THREE.Mesh(bannerGeom, bannerMat);
            bannerMesh.castShadow = true;
            bannerMesh.position.y = -CONFIG.bannerHeight / 2;
            rootGroup.add(bannerMesh);

            // Accordion Logic
            let parent = rootGroup;
            let isInteracting = false; 
            let isClosing = false; 

            CONFIG.categories.forEach((cat, i) => {
                const hinge = new THREE.Group();
                if(i === 0) hinge.position.y = -CONFIG.bannerHeight;
                else hinge.position.y = -CONFIG.cardHeight;
                
                if(i === 0) rootGroup.add(hinge); 
                else parent.add(hinge);           

                hinges.push(hinge);
                parent = hinge;

                const geom = new THREE.PlaneGeometry(CONFIG.cardWidth, CONFIG.cardHeight, 40, 1);
                geom.translate(0, -CONFIG.cardHeight/2, 0);

                // Create Texture Maps
                const texNormal = createCardTexture(cat, 'normal');
                const texHover = createCardTexture(cat, 'hover');

                // Material 1: Standard (Reacts to light/shadow)
                const matNormal = new THREE.MeshStandardMaterial({
                    map: texNormal,
                    side: THREE.DoubleSide,
                    roughness: 0.5, 
                    metalness: 0.5
                });

                // Material 2: Basic (Ignores light -> Uniform flat appearance)
                const matHover = new THREE.MeshBasicMaterial({
                    map: texHover,
                    side: THREE.DoubleSide
                });

                const mesh = new THREE.Mesh(geom, matNormal);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                // Store materials for swapping
                mesh.userData = { 
                    id: i, 
                    name: cat,
                    matNormal: matNormal,
                    matHover: matHover
                };
                
                hinge.add(mesh);
                meshes.push(mesh); 
            });

            // --- ANIMATION ---
            function updateFolds(angle) {
                hinges.forEach((h, i) => {
                    if(i === 0) h.rotation.x = angle;
                    else {
                        const sign = (i % 2 === 0) ? 1 : -1;
                        h.rotation.x = angle * 2 * sign;
                    }
                });
            }

            const animState = { angle: CONFIG.closedAngle };
            updateFolds(CONFIG.closedAngle);

            gsap.to(animState, {
                angle: CONFIG.openAngle,
                duration: 2.5,
                ease: "elastic.out(1, 0.6)",
                delay: 0.5,
                onUpdate: () => updateFolds(animState.angle),
                onComplete: () => { isInteracting = true; }
            });

            // --- INTERACTION ---
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let hoveredIndex = -1;

            window.addEventListener('mousemove', (e) => {
                if(!isInteracting || isClosing) return;

                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(meshes);

                if(intersects.length > 0) {
                    const index = intersects[0].object.userData.id;
                    if(hoveredIndex !== index) {
                        hoveredIndex = index;
                        updateHoverState();
                        document.body.style.cursor = 'pointer';
                    }
                } else {
                    if(hoveredIndex !== -1) {
                        hoveredIndex = -1;
                        updateHoverState();
                        document.body.style.cursor = 'default';
                    }
                }
            });

            function updateHoverState() {
                meshes.forEach((mesh, i) => {
                    if(i === hoveredIndex) {
                        // HOVER: Switch to Basic Material (Unlit/Uniform)
                        // This makes every fold look identical regardless of angle
                        if(mesh.material !== mesh.userData.matHover) {
                            mesh.material = mesh.userData.matHover;
                        }
                    } else {
                        // NORMAL: Switch to Standard Material (Lit)
                        if(mesh.material !== mesh.userData.matNormal) {
                            mesh.material = mesh.userData.matNormal;
                        }
                    }
                });
            }

            // --- NAVIGATION ---
            window.addEventListener('click', () => {
                if(hoveredIndex !== -1 && !isClosing && isInteracting) {
                    isClosing = true;
                    const selectedCategory = meshes[hoveredIndex].userData.name;

                    // Ensure visual reset to normal before folding
                    const mesh = meshes[hoveredIndex];
                    mesh.material = mesh.userData.matNormal;

                    gsap.to(animState, {
                        angle: CONFIG.closedAngle,
                        duration: 0.8,
                        ease: "power2.inOut",
                        onUpdate: () => updateFolds(animState.angle),
                        onComplete: () => {
                            console.log(`Navigating to: ${selectedCategory}`);
                            alert(`Loading ${selectedCategory}`);
                            // window.location.href = `/events/${selectedCategory.replace(/\s+/g, '-').toLowerCase()}`;
                        }
                    });
                }
            });

            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        initApp();
    </script>
</body>
</html>