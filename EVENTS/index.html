<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ISHYA '26 | Event Selection</title>
    
    <!-- FONTS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Syncopate:wght@400;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    
    <!-- GLOBAL CSS & LAYOUT -->
    <link rel="stylesheet" href="/global.css">
    <script src="/layout.js" defer></script>

    <!-- GSAP & THREE -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script type="module" src="https://unpkg.com/three@0.160.0/build/three.module.js"></script>
    
    <style>
        :root {
            --bg-dark: #051408;       
            --accent-gold: #D6C26A;   
            --font-tech: 'Share Tech Mono', monospace;
        }

        body { 
            margin: 0; 
            overflow: hidden; /* CRITICAL: Keeps 3D raycasting accurate */
            background-color: var(--bg-dark); 
            font-family: var(--font-tech);
            width: 100vw;
            height: 100vh;
        }

        /* --- HEADER OVERRIDES FOR THIS PAGE ONLY --- */
        /* 1. Hide the dark full-width bar */
        ishya-header .ishya-nav-backdrop {
            display: none !important;
        }
        /* 2. Remove the layout spacer */
        ishya-header .ishya-header-spacer {
            display: none !important;
        }
        /* 3. Style the pill to float cleanly */
        ishya-header .ishya-nav-container {
            top: 25px !important;
            background: rgba(5, 20, 8, 0.6) !important; /* Semi-transparent dark bg */
            border: 1px solid rgba(214, 194, 106, 0.4) !important;
            backdrop-filter: blur(5px);
        }

        /* LOADER & LAYERS */
        #font-loader-text { font-family: 'Cinzel'; font-weight: 900; opacity: 0; position: absolute; pointer-events: none;}
        #font-loader-icon { font-family: 'Font Awesome 6 Free'; font-weight: 900; opacity: 0; position: absolute; pointer-events: none;}

        #animated-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -10; pointer-events: none; }
        .overlay-grain {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.04'/%3E%3C/svg%3E");
            pointer-events: none; z-index: 5; opacity: 0.6;
        }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
    </style>
</head>
<body>

    <ishya-header></ishya-header>

    <div id="font-loader-text">ISHYA LOADING</div>
    <div id="font-loader-icon" class="fa-solid fa-gamepad"></div>

    <canvas id="animated-bg"></canvas>
    <div class="overlay-grain"></div>
    <div id="canvas-container"></div>

    <!-- BACKGROUND ANIMATION SCRIPT (unchanged) -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('animated-bg');
            const ctx = canvas.getContext('2d');
            let width, height;
            const isMobile = window.innerWidth < 950;
            const COLORS = { trail: 'rgba(5, 20, 8, 0.15)', swirlGreen: 'rgba(77, 183, 72, 0.1)', gold: 'rgba(214, 194, 106, 0.3)', mandala: 'rgba(214, 194, 106, 0.08)' };
            const particles = []; let mandalas = [];
            function resize() {
                width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight;
                mandalas = [new Mandala(width/2, height*0.4, Math.min(width,height)*0.45, 0.0005, COLORS.mandala)];
                particles.length = 0;
                const pCount = isMobile ? 30 : 100;
                for(let i=0; i<pCount; i++) particles.push(new FlowParticle());
            }
            class FlowParticle {
                constructor() { this.x = Math.random()*width; this.y = Math.random()*height; this.speed = Math.random()*1.0+0.2; this.angle = 0; this.size = Math.random()*2+0.5; this.color = Math.random()>0.8 ? COLORS.gold : COLORS.swirlGreen; }
                update() { const n = Math.sin(this.x*0.002) * Math.cos(this.y*0.002); this.angle = n * Math.PI * 4; this.x += Math.cos(this.angle)*this.speed; this.y += Math.sin(this.angle)*this.speed; if(this.x<0)this.x=width; if(this.x>width)this.x=0; if(this.y<0)this.y=height; if(this.y>height)this.y=0; }
                draw() { ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); }
            }
            class Mandala {
                constructor(x,y,r,s,c) { this.x=x;this.y=y;this.r=r;this.s=s;this.angle=0;this.c=c; }
                update() { this.angle+=this.s; }
                draw() { ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle); ctx.strokeStyle=this.c; ctx.lineWidth=2; for(let i=0;i<12;i++){ ctx.rotate(Math.PI*2/12); ctx.beginPath(); ctx.moveTo(0,0); ctx.quadraticCurveTo(this.r*0.5,this.r*0.5,0,this.r); ctx.quadraticCurveTo(-this.r*0.5,this.r*0.5,0,0); ctx.stroke(); } ctx.restore(); }
            }
            function animate() { ctx.fillStyle=COLORS.trail; ctx.fillRect(0,0,width,height); mandalas.forEach(m=>{m.update();m.draw();}); particles.forEach(p=>{p.update();p.draw();}); requestAnimationFrame(animate); }
            window.addEventListener('resize', resize); resize(); animate();
        });
    </script>

    <!-- MAIN 3D LOGIC -->
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        const ICONS = { masks: "\uf630", music: "\uf001", feather: "\uf56b", mic: "\uf130", palette: "\uf53f", brush: "\uf1fc", gamepad: "\uf11b", headset: "\uf590", camera: "\uf030", film: "\uf008" };
        const CONFIG = {
            bannerWidth: 50, bannerHeight: 18, cardWidth: 50, cardHeight: 14,
            closedAngle: 1.55, openAngle: 0.18,   
            categories: [
                { name: "PERFORMING ARTS", iconL: ICONS.masks, iconR: ICONS.music },
                { name: "LITERARY & ORATORY", iconL: ICONS.feather, iconR: ICONS.mic },
                { name: "VISUAL & FINE ARTS", iconL: ICONS.palette, iconR: ICONS.brush },
                { name: "GAMING & ESPORTS", iconL: ICONS.gamepad, iconR: ICONS.headset },
                { name: "MEDIA & PHOTO", iconL: ICONS.camera, iconR: ICONS.film }
            ]
        };

        async function initApp() {
            await document.fonts.ready;
            const container = document.getElementById('canvas-container');
            const scene = new THREE.Scene(); scene.background = null; 
            const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 0, 110); 
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            scene.add(new THREE.AmbientLight(0x051408, 0.8));
            const dirLight = new THREE.DirectionalLight(0xD6C26A, 1.8);
            dirLight.position.set(10, 50, 60); dirLight.castShadow = true; dirLight.shadow.bias = -0.001; 
            scene.add(dirLight);

            function getSafeFontSize(ctx, text, baseSize, maxWid) {
                ctx.font = `900 ${baseSize}px 'Cinzel', serif`;
                let width = ctx.measureText(text).width;
                if(width > maxWid) return Math.floor(baseSize * (maxWid / width));
                return baseSize;
            }

            function createCardTexture(data) {
                const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 256; const ctx = canvas.getContext('2d');
                const grad = ctx.createLinearGradient(0,0,0,256); grad.addColorStop(0, '#8a6e28'); grad.addColorStop(0.2, '#D6C26A'); grad.addColorStop(0.5, '#fcf6ba'); grad.addColorStop(0.8, '#D6C26A'); grad.addColorStop(1, '#8a6e28');
                ctx.fillStyle = grad; ctx.fillRect(0,0,1024,256);
                ctx.fillStyle = "rgba(0,0,0,0.12)"; for(let i=0; i<8000; i++) ctx.fillRect(Math.random()*1024, Math.random()*256, 1.5, 1.5);
                const iconPad = 40; const iconWid = 60; const maxTextWidth = 1024 - (2 * (iconPad + iconWid + 20)); const fontSize = getSafeFontSize(ctx, data.name, 65, maxTextWidth);
                ctx.fillStyle = "#051408"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.font = `900 ${fontSize}px 'Cinzel', serif`; ctx.fillText(data.name, 512, 128);
                ctx.font = "900 55px 'Font Awesome 6 Free'"; ctx.fillText(data.iconL, iconPad + 30, 128); ctx.fillText(data.iconR, 1024 - (iconPad + 30), 128);
                const tex = new THREE.CanvasTexture(canvas); tex.colorSpace = THREE.SRGBColorSpace; tex.anisotropy = 16; return tex;
            }

            function createBannerTexture() {
                const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 368; const ctx = canvas.getContext('2d');
                const grad = ctx.createLinearGradient(0,0,0,368); grad.addColorStop(0, '#3e2b18'); grad.addColorStop(0.5, '#5a461b'); grad.addColorStop(1, '#3e2b18');
                ctx.fillStyle = grad; ctx.fillRect(0,0,1024,368);
                ctx.fillStyle = "rgba(0,0,0,0.2)"; for(let i=0; i<10000; i++) ctx.fillRect(Math.random()*1024, Math.random()*368, 2, 2);
                ctx.lineWidth = 15; ctx.strokeStyle = "#D6C26A"; ctx.strokeRect(10,10,1004,348);
                ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillStyle = "#D6C26A"; 
                ctx.shadowColor="rgba(0,0,0,0.5)"; ctx.shadowBlur=10; ctx.font = "900 110px 'Cinzel', serif"; ctx.fillText("ISHYA '26", 512, 140);
                ctx.shadowBlur=0; ctx.fillStyle = "#e0e0e0"; ctx.letterSpacing = "5px"; ctx.font = "700 35px 'Syncopate', sans-serif"; ctx.fillText("FLAMES IN EVERY FOLD", 512, 250);
                const tex = new THREE.CanvasTexture(canvas); tex.colorSpace = THREE.SRGBColorSpace; tex.minFilter = THREE.LinearFilter; return tex;
            }

            const hinges = []; const meshes = []; const rootGroup = new THREE.Group();
            
            // --- FIX START: SCALE DOWN AND RE-CENTER ---
            // 1. Scale down to 0.85 (85% size) to create top/bottom margins
            rootGroup.scale.set(0.85, 0.85, 0.85);

            // 2. Position Y at 35. 
            // (Previous 42 was too high, 30 was too low. 35 is the sweet spot for this scale)
            rootGroup.position.set(0, 35, 0); 
            // --- FIX END ---
            
            scene.add(rootGroup);

            const bannerMesh = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.bannerWidth, CONFIG.bannerHeight), new THREE.MeshStandardMaterial({ map: createBannerTexture(), roughness: 0.7, metalness: 0.3, side: THREE.DoubleSide }));
            bannerMesh.castShadow = true; bannerMesh.position.y = -CONFIG.bannerHeight / 2; rootGroup.add(bannerMesh);

            let parent = rootGroup;
            CONFIG.categories.forEach((catData, i) => {
                const hinge = new THREE.Group(); hinge.position.y = (i === 0) ? -CONFIG.bannerHeight : -CONFIG.cardHeight; (i === 0) ? rootGroup.add(hinge) : parent.add(hinge); hinges.push(hinge); parent = hinge;
                const geom = new THREE.PlaneGeometry(CONFIG.cardWidth, CONFIG.cardHeight, 40, 1); geom.translate(0, -CONFIG.cardHeight/2, 0);
                const texNormal = createCardTexture(catData);
                const hoverCanvas = document.createElement('canvas'); hoverCanvas.width = 1024; hoverCanvas.height = 256; const texHover = new THREE.CanvasTexture(hoverCanvas); texHover.colorSpace = THREE.SRGBColorSpace; texHover.anisotropy = 16;
                const matNormal = new THREE.MeshStandardMaterial({ map: texNormal, side: THREE.DoubleSide, roughness: 0.5, metalness: 0.5 });
                const matHover = new THREE.MeshBasicMaterial({ map: texHover, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geom, matNormal); mesh.castShadow = true; mesh.receiveShadow = true;
                mesh.userData = { id: i, name: catData.name, data: catData, matNormal: matNormal, matHover: matHover, hoverCanvas: hoverCanvas, texHover: texHover, anim: { progress: 0 } };
                hinge.add(mesh); meshes.push(mesh); 
            });

            function updateFolds(angle) { hinges.forEach((h, i) => { h.rotation.x = (i === 0) ? angle : angle * 2 * ((i % 2 === 0) ? 1 : -1); }); }
            const animState = { angle: CONFIG.closedAngle }; updateFolds(CONFIG.closedAngle);
            gsap.to(animState, { angle: CONFIG.openAngle, duration: 2.5, ease: "elastic.out(1, 0.6)", delay: 0.5, onUpdate: () => updateFolds(animState.angle), onComplete: () => { isInteracting = true; } });

            let isInteracting = false; let isClosing = false; let activeHoverIndex = -1;
            function updateActiveCardTexture(mesh) {
                if(mesh.material !== mesh.userData.matHover) return;
                const ctx = mesh.userData.hoverCanvas.getContext('2d'); const p = mesh.userData.anim.progress; const data = mesh.userData.data;
                ctx.fillStyle = "#051408"; ctx.fillRect(0,0,1024,256); ctx.fillStyle = "rgba(255,255,255,0.04)"; for(let i=0; i<1000; i++) ctx.fillRect(Math.random()*1024, Math.random()*256, 1, 1);
                const scale = 1.0 + (p * 0.05); const iconPad = 40; const iconWid = 60; const maxTextWidth = 1024 - (2 * (iconPad + iconWid + 20)); 
                let fontSize = getSafeFontSize(ctx, data.name, 65, maxTextWidth); fontSize = fontSize * scale;
                ctx.save(); ctx.translate(512, 128); ctx.font = `900 ${fontSize}px 'Cinzel', serif`; ctx.fillStyle = "#D6C26A"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(data.name, 0, 0);
                ctx.font = `900 ${55 * scale}px 'Font Awesome 6 Free'`; ctx.fillText(data.iconL, -(512 - (iconPad+30)), 0); ctx.fillText(data.iconR, (512 - (iconPad+30)), 0); ctx.restore();
                const perim = 2560; ctx.lineWidth = 15; ctx.strokeStyle = "#D6C26A"; ctx.setLineDash([perim * p, perim]); ctx.lineDashOffset = 0; ctx.strokeRect(0, 0, 1024, 256);
                mesh.userData.texHover.needsUpdate = true;
            }

            const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();
            window.addEventListener('mousemove', (e) => {
                if(!isInteracting || isClosing) return;
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObjects(meshes);
                if(intersects.length > 0) { const idx = intersects[0].object.userData.id; if(activeHoverIndex !== idx) { switchHover(idx); document.body.style.cursor = 'pointer'; } } 
                else { if(activeHoverIndex !== -1) { switchHover(-1); document.body.style.cursor = 'default'; } }
            });

            function switchHover(newIndex) {
                if(activeHoverIndex !== -1) { const mesh = meshes[activeHoverIndex]; mesh.material = mesh.userData.matNormal; gsap.killTweensOf(mesh.userData.anim); mesh.userData.anim.progress = 0; }
                activeHoverIndex = newIndex;
                if(activeHoverIndex !== -1) { const mesh = meshes[activeHoverIndex]; mesh.material = mesh.userData.matHover; gsap.to(mesh.userData.anim, { progress: 1, duration: 0.4, ease: "power2.out" }); }
            }

            window.addEventListener('click', () => {
                if(activeHoverIndex !== -1 && !isClosing && isInteracting) {
                    isClosing = true; const catName = meshes[activeHoverIndex].userData.name; meshes[activeHoverIndex].material = meshes[activeHoverIndex].userData.matNormal;
                    gsap.to(animState, { angle: CONFIG.closedAngle, duration: 0.8, ease: "power2.inOut", onUpdate: () => updateFolds(animState.angle), onComplete: () => { window.location.href = `events_landed.html?category=${encodeURIComponent(catName)}`; } });
                }
            });

            function animate() { requestAnimationFrame(animate); if(activeHoverIndex !== -1) updateActiveCardTexture(meshes[activeHoverIndex]); renderer.render(scene, camera); }
            animate();
            // window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                
                // --- OPTIONAL RESPONSIVE TWEAK ---
                // If screen gets very short, shrink it a bit more automatically
                if(window.innerHeight < 800) {
                    rootGroup.scale.set(0.75, 0.75, 0.75);
                } else {
                    rootGroup.scale.set(0.85, 0.85, 0.85);
                }
            });
        }
        // --- FIX FOR MOBILE BACK BUTTON (BFCache) ---
        // This detects if the page is being loaded from the "Back-Forward Cache"
        window.addEventListener('pageshow', (event) => {
            if (event.persisted) {
                // If the page is restored from cache, the 3D context might be stuck
                // in the "Closed" state. The safest fix for 3D canvases is to force a reload.
                window.location.reload();
            }
        });
        initApp();

        // FIX FOR MOBILE BACK NAVIGATION
        // This listens for when the page is shown (even from back-cache)
    </script>
</body>
</html>
